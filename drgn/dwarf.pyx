from cpython.buffer cimport PyObject_GetBuffer, PyBuffer_Release, Py_buffer, PyBUF_SIMPLE
from cpython.mem cimport PyMem_Realloc, PyMem_Free
from libc.stdint cimport int64_t, uint8_t, uint16_t, uint32_t, uint64_t, UINT32_MAX, UINT64_MAX
from libc.string cimport memchr, memcpy


import enum


cdef extern from "Python.h":
    Py_ssize_t PY_SSIZE_T_MAX
    void *PyMem_Calloc(size_t nelem, size_t elsize)
    str PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
    bytes PyBytes_FromStringAndSize(const char *v, Py_ssize_t size)


cdef extern from "stdint.h":
    uint64_t UINT64_C(uint64_t)


cdef inline bint in_bounds(Py_ssize_t buffer_size, Py_ssize_t offset,
                           Py_ssize_t size) nogil:
    return offset >= 0 and buffer_size >= size and offset <= buffer_size - size


cdef inline int check_bounds(Py_ssize_t buffer_size, Py_ssize_t offset,
                             Py_ssize_t size) except -1:
    if not in_bounds(buffer_size, offset, size):
        raise EOFError()
    return 0


cdef inline int read_buffer(const char *buffer, Py_ssize_t buffer_size,
                            Py_ssize_t *offset, void *ret,
                            Py_ssize_t size) except -1:
    check_bounds(buffer_size, offset[0], size)
    memcpy(ret, buffer + offset[0], size)
    offset[0] += size
    return 0


cdef inline bytes read_bytes(const char *buffer, Py_ssize_t buffer_size,
                             Py_ssize_t *offset, Py_ssize_t size):
    check_bounds(buffer_size, offset[0], size)
    cdef bytes ret = PyBytes_FromStringAndSize(buffer + offset[0], size)
    offset[0] += size
    return ret


cdef inline str read_str(const char *buffer, Py_ssize_t buffer_size,
                         Py_ssize_t *offset):
    if offset[0] >= buffer_size:
        raise EOFError()

    cdef const char *p = buffer + offset[0]
    cdef const char *nul = <const char *>memchr(p, 0, buffer_size - offset[0])
    if nul == NULL:
        raise ValueError('unterminated string')
    offset[0] += (nul - p) + 1
    return PyUnicode_FromStringAndSize(p, nul - p)


cdef inline Py_ssize_t read_strlen(const char *buffer, Py_ssize_t buffer_size,
                                   Py_ssize_t *offset) except -1:
    if offset[0] >= buffer_size:
        raise EOFError()

    cdef const char *p = buffer + offset[0]
    cdef const char *nul = <const char *>memchr(p, 0, buffer_size - offset[0])
    if nul == NULL:
        raise ValueError('unterminated string')
    cdef Py_ssize_t ret = nul - p
    offset[0] += ret + 1
    return ret


# Automatically generated by generate_readwrite.py
cdef inline int read_u8(const char *buffer, Py_ssize_t buffer_size, Py_ssize_t *offset, uint8_t *ret) except -1:
    if not in_bounds(buffer_size, offset[0], sizeof(uint8_t)):
        raise EOFError()
    ret[0] = (<const uint8_t *>(buffer + offset[0]))[0]
    offset[0] += sizeof(uint8_t)
    return 0


cdef inline int read_u8_into_u64(const char *buffer, Py_ssize_t buffer_size, Py_ssize_t *offset, uint64_t *ret) except -1:
    if not in_bounds(buffer_size, offset[0], sizeof(uint8_t)):
        raise EOFError()
    ret[0] = (<const uint8_t *>(buffer + offset[0]))[0]
    offset[0] += sizeof(uint8_t)
    return 0


cdef inline int read_u8_into_ssize_t(const char *buffer, Py_ssize_t buffer_size, Py_ssize_t *offset, Py_ssize_t *ret) except -1:
    if not in_bounds(buffer_size, offset[0], sizeof(uint8_t)):
        raise EOFError()
    ret[0] = (<const uint8_t *>(buffer + offset[0]))[0]
    offset[0] += sizeof(uint8_t)
    return 0


cdef inline int read_u16(const char *buffer, Py_ssize_t buffer_size, Py_ssize_t *offset, uint16_t *ret) except -1:
    if not in_bounds(buffer_size, offset[0], sizeof(uint16_t)):
        raise EOFError()
    ret[0] = (<const uint16_t *>(buffer + offset[0]))[0]
    offset[0] += sizeof(uint16_t)
    return 0


cdef inline int read_u16_into_u64(const char *buffer, Py_ssize_t buffer_size, Py_ssize_t *offset, uint64_t *ret) except -1:
    if not in_bounds(buffer_size, offset[0], sizeof(uint16_t)):
        raise EOFError()
    ret[0] = (<const uint16_t *>(buffer + offset[0]))[0]
    offset[0] += sizeof(uint16_t)
    return 0


cdef inline int read_u16_into_ssize_t(const char *buffer, Py_ssize_t buffer_size, Py_ssize_t *offset, Py_ssize_t *ret) except -1:
    if not in_bounds(buffer_size, offset[0], sizeof(uint16_t)):
        raise EOFError()
    ret[0] = (<const uint16_t *>(buffer + offset[0]))[0]
    offset[0] += sizeof(uint16_t)
    return 0


cdef inline int read_u32(const char *buffer, Py_ssize_t buffer_size, Py_ssize_t *offset, uint32_t *ret) except -1:
    if not in_bounds(buffer_size, offset[0], sizeof(uint32_t)):
        raise EOFError()
    ret[0] = (<const uint32_t *>(buffer + offset[0]))[0]
    offset[0] += sizeof(uint32_t)
    return 0


cdef inline int read_u32_into_u64(const char *buffer, Py_ssize_t buffer_size, Py_ssize_t *offset, uint64_t *ret) except -1:
    if not in_bounds(buffer_size, offset[0], sizeof(uint32_t)):
        raise EOFError()
    ret[0] = (<const uint32_t *>(buffer + offset[0]))[0]
    offset[0] += sizeof(uint32_t)
    return 0


cdef inline int read_u32_into_ssize_t(const char *buffer, Py_ssize_t buffer_size, Py_ssize_t *offset, Py_ssize_t *ret) except -1:
    if not in_bounds(buffer_size, offset[0], sizeof(uint32_t)):
        raise EOFError()
    ret[0] = (<const uint32_t *>(buffer + offset[0]))[0]
    offset[0] += sizeof(uint32_t)
    return 0


cdef inline int read_u64(const char *buffer, Py_ssize_t buffer_size, Py_ssize_t *offset, uint64_t *ret) except -1:
    if not in_bounds(buffer_size, offset[0], sizeof(uint64_t)):
        raise EOFError()
    ret[0] = (<const uint64_t *>(buffer + offset[0]))[0]
    offset[0] += sizeof(uint64_t)
    return 0


cdef inline int read_uleb128(const char *buffer, Py_ssize_t buffer_size,
                             Py_ssize_t *offset, uint64_t *ret) except -1:
    cdef int shift = 0
    cdef uint8_t byte

    ret[0] = 0
    while True:
        read_u8(buffer, buffer_size, offset, &byte)
        if shift == 63 and byte > 1:
            raise OverflowError('ULEB128 overflowed unsigned 64-bit integer')
        ret[0] |= <uint64_t>(byte & 0x7f) << shift
        shift += 7
        if not (byte & 0x80):
            break
    return 0


cdef inline int read_sleb128(const char *buffer, Py_ssize_t buffer_size,
                             Py_ssize_t *offset, int64_t *ret) except -1:
    cdef int shift = 0
    cdef uint8_t byte

    ret[0] = 0
    while True:
        read_u8(buffer, buffer_size, offset, &byte)
        if shift == 63 and byte != 0 and byte != 0x7f:
            raise OverflowError('SLEB128 overflowed signed 64-bit integer')
        ret[0] |= <uint64_t>(byte & 0x7f) << shift
        shift += 7
        if not (byte & 0x80):
            break
    if shift < 64 and (byte & 0x40):
        ret[0] |= ~(UINT64_C(1) << shift) + 1
    return 0


class DW_AT(enum.IntEnum):
    sibling = 0x1
    location = 0x2
    name = 0x3
    ordering = 0x9
    subscr_data = 0xa
    byte_size = 0xb
    bit_offset = 0xc
    bit_size = 0xd
    element_list = 0xf
    stmt_list = 0x10
    low_pc = 0x11
    high_pc = 0x12
    language = 0x13
    member = 0x14
    discr = 0x15
    discr_value = 0x16
    visibility = 0x17
    import_ = 0x18
    string_length = 0x19
    common_reference = 0x1a
    comp_dir = 0x1b
    const_value = 0x1c
    containing_type = 0x1d
    default_value = 0x1e
    inline = 0x20
    is_optional = 0x21
    lower_bound = 0x22
    producer = 0x25
    prototyped = 0x27
    return_addr = 0x2a
    start_scope = 0x2c
    bit_stride = 0x2e
    upper_bound = 0x2f
    abstract_origin = 0x31
    accessibility = 0x32
    address_class = 0x33
    artificial = 0x34
    base_types = 0x35
    calling_convention = 0x36
    count = 0x37
    data_member_location = 0x38
    decl_column = 0x39
    decl_file = 0x3a
    decl_line = 0x3b
    declaration = 0x3c
    discr_list = 0x3d
    encoding = 0x3e
    external = 0x3f
    frame_base = 0x40
    friend = 0x41
    identifier_case = 0x42
    macro_info = 0x43
    namelist_item = 0x44
    priority = 0x45
    segment = 0x46
    specification = 0x47
    static_link = 0x48
    type = 0x49
    use_location = 0x4a
    variable_parameter = 0x4b
    virtuality = 0x4c
    vtable_elem_location = 0x4d
    allocated = 0x4e
    associated = 0x4f
    data_location = 0x50
    byte_stride = 0x51
    entry_pc = 0x52
    use_UTF8 = 0x53
    extension = 0x54
    ranges = 0x55
    trampoline = 0x56
    call_column = 0x57
    call_file = 0x58
    call_line = 0x59
    description = 0x5a
    binary_scale = 0x5b
    decimal_scale = 0x5c
    small = 0x5d
    decimal_sign = 0x5e
    digit_count = 0x5f
    picture_string = 0x60
    mutable = 0x61
    threads_scaled = 0x62
    explicit = 0x63
    object_pointer = 0x64
    endianity = 0x65
    elemental = 0x66
    pure = 0x67
    recursive = 0x68
    signature = 0x69
    main_subprogram = 0x6a
    data_bit_offset = 0x6b
    const_expr = 0x6c
    enum_class = 0x6d
    linkage_name = 0x6e
    noreturn = 0x87
    lo_user = 0x2000
    MIPS_fde = 0x2001
    MIPS_loop_begin = 0x2002
    MIPS_tail_loop_begin = 0x2003
    MIPS_epilog_begin = 0x2004
    MIPS_loop_unroll_factor = 0x2005
    MIPS_software_pipeline_depth = 0x2006
    MIPS_linkage_name = 0x2007
    MIPS_stride = 0x2008
    MIPS_abstract_name = 0x2009
    MIPS_clone_origin = 0x200a
    MIPS_has_inlines = 0x200b
    MIPS_stride_byte = 0x200c
    MIPS_stride_elem = 0x200d
    MIPS_ptr_dopetype = 0x200e
    MIPS_allocatable_dopetype = 0x200f
    MIPS_assumed_shape_dopetype = 0x2010
    MIPS_assumed_size = 0x2011
    sf_names = 0x2101
    src_info = 0x2102
    mac_info = 0x2103
    src_coords = 0x2104
    body_begin = 0x2105
    body_end = 0x2106
    GNU_vector = 0x2107
    GNU_guarded_by = 0x2108
    GNU_pt_guarded_by = 0x2109
    GNU_guarded = 0x210a
    GNU_pt_guarded = 0x210b
    GNU_locks_excluded = 0x210c
    GNU_exclusive_locks_required = 0x210d
    GNU_shared_locks_required = 0x210e
    GNU_odr_signature = 0x210f
    GNU_template_name = 0x2110
    GNU_call_site_value = 0x2111
    GNU_call_site_data_value = 0x2112
    GNU_call_site_target = 0x2113
    GNU_call_site_target_clobbered = 0x2114
    GNU_tail_call = 0x2115
    GNU_all_tail_call_sites = 0x2116
    GNU_all_call_sites = 0x2117
    GNU_all_source_call_sites = 0x2118
    GNU_macros = 0x2119
    GNU_deleted = 0x211a
    hi_user = 0x3fff

    @classmethod
    def str(cls, value):
        try:
            return f'DW_AT_{cls(value).name}'
        except ValueError:
            return hex(value)


class DW_ATE(enum.IntEnum):
    void = 0x0
    address = 0x1
    boolean = 0x2
    complex_float = 0x3
    float = 0x4
    signed = 0x5
    signed_char = 0x6
    unsigned = 0x7
    unsigned_char = 0x8
    imaginary_float = 0x9
    packed_decimal = 0xa
    numeric_string = 0xb
    edited = 0xc
    signed_fixed = 0xd
    unsigned_fixed = 0xe
    decimal_float = 0xf
    UTF = 0x10
    lo_user = 0x80
    hi_user = 0xff

    @classmethod
    def str(cls, value):
        try:
            return f'DW_ATE_{cls(value).name}'
        except ValueError:
            return hex(value)


class DW_CHILDREN(enum.IntEnum):
    no = 0x0
    yes = 0x1

    @classmethod
    def str(cls, value):
        try:
            return f'DW_CHILDREN_{cls(value).name}'
        except ValueError:
            return hex(value)


class DW_FORM(enum.IntEnum):
    addr = 0x1
    block2 = 0x3
    block4 = 0x4
    data2 = 0x5
    data4 = 0x6
    data8 = 0x7
    string = 0x8
    block = 0x9
    block1 = 0xa
    data1 = 0xb
    flag = 0xc
    sdata = 0xd
    strp = 0xe
    udata = 0xf
    ref_addr = 0x10
    ref1 = 0x11
    ref2 = 0x12
    ref4 = 0x13
    ref8 = 0x14
    ref_udata = 0x15
    indirect = 0x16
    sec_offset = 0x17
    exprloc = 0x18
    flag_present = 0x19
    ref_sig8 = 0x20

    @classmethod
    def str(cls, value):
        try:
            return f'DW_FORM_{cls(value).name}'
        except ValueError:
            return hex(value)


class DW_LNE(enum.IntEnum):
    end_sequence = 0x1
    set_address = 0x2
    define_file = 0x3
    set_discriminator = 0x4
    lo_user = 0x80
    hi_user = 0xff

    @classmethod
    def str(cls, value):
        try:
            return f'DW_LNE_{cls(value).name}'
        except ValueError:
            return hex(value)


class DW_LNS(enum.IntEnum):
    copy = 0x1
    advance_pc = 0x2
    advance_line = 0x3
    set_file = 0x4
    set_column = 0x5
    negate_stmt = 0x6
    set_basic_block = 0x7
    const_add_pc = 0x8
    fixed_advance_pc = 0x9
    set_prologue_end = 0xa
    set_epilogue_begin = 0xb
    set_isa = 0xc

    @classmethod
    def str(cls, value):
        try:
            return f'DW_LNS_{cls(value).name}'
        except ValueError:
            return hex(value)


class DW_OP(enum.IntEnum):
    addr = 0x3
    deref = 0x6
    const1u = 0x8
    const1s = 0x9
    const2u = 0xa
    const2s = 0xb
    const4u = 0xc
    const4s = 0xd
    const8u = 0xe
    const8s = 0xf
    constu = 0x10
    consts = 0x11
    dup = 0x12
    drop = 0x13
    over = 0x14
    pick = 0x15
    swap = 0x16
    rot = 0x17
    xderef = 0x18
    abs = 0x19
    and_ = 0x1a
    div = 0x1b
    minus = 0x1c
    mod = 0x1d
    mul = 0x1e
    neg = 0x1f
    not_ = 0x20
    or_ = 0x21
    plus = 0x22
    plus_uconst = 0x23
    shl = 0x24
    shr = 0x25
    shra = 0x26
    xor = 0x27
    bra = 0x28
    eq = 0x29
    ge = 0x2a
    gt = 0x2b
    le = 0x2c
    lt = 0x2d
    ne = 0x2e
    skip = 0x2f
    lit0 = 0x30
    lit1 = 0x31
    lit2 = 0x32
    lit3 = 0x33
    lit4 = 0x34
    lit5 = 0x35
    lit6 = 0x36
    lit7 = 0x37
    lit8 = 0x38
    lit9 = 0x39
    lit10 = 0x3a
    lit11 = 0x3b
    lit12 = 0x3c
    lit13 = 0x3d
    lit14 = 0x3e
    lit15 = 0x3f
    lit16 = 0x40
    lit17 = 0x41
    lit18 = 0x42
    lit19 = 0x43
    lit20 = 0x44
    lit21 = 0x45
    lit22 = 0x46
    lit23 = 0x47
    lit24 = 0x48
    lit25 = 0x49
    lit26 = 0x4a
    lit27 = 0x4b
    lit28 = 0x4c
    lit29 = 0x4d
    lit30 = 0x4e
    lit31 = 0x4f
    reg0 = 0x50
    reg1 = 0x51
    reg2 = 0x52
    reg3 = 0x53
    reg4 = 0x54
    reg5 = 0x55
    reg6 = 0x56
    reg7 = 0x57
    reg8 = 0x58
    reg9 = 0x59
    reg10 = 0x5a
    reg11 = 0x5b
    reg12 = 0x5c
    reg13 = 0x5d
    reg14 = 0x5e
    reg15 = 0x5f
    reg16 = 0x60
    reg17 = 0x61
    reg18 = 0x62
    reg19 = 0x63
    reg20 = 0x64
    reg21 = 0x65
    reg22 = 0x66
    reg23 = 0x67
    reg24 = 0x68
    reg25 = 0x69
    reg26 = 0x6a
    reg27 = 0x6b
    reg28 = 0x6c
    reg29 = 0x6d
    reg30 = 0x6e
    reg31 = 0x6f
    breg0 = 0x70
    breg1 = 0x71
    breg2 = 0x72
    breg3 = 0x73
    breg4 = 0x74
    breg5 = 0x75
    breg6 = 0x76
    breg7 = 0x77
    breg8 = 0x78
    breg9 = 0x79
    breg10 = 0x7a
    breg11 = 0x7b
    breg12 = 0x7c
    breg13 = 0x7d
    breg14 = 0x7e
    breg15 = 0x7f
    breg16 = 0x80
    breg17 = 0x81
    breg18 = 0x82
    breg19 = 0x83
    breg20 = 0x84
    breg21 = 0x85
    breg22 = 0x86
    breg23 = 0x87
    breg24 = 0x88
    breg25 = 0x89
    breg26 = 0x8a
    breg27 = 0x8b
    breg28 = 0x8c
    breg29 = 0x8d
    breg30 = 0x8e
    breg31 = 0x8f
    regx = 0x90
    fbreg = 0x91
    bregx = 0x92
    piece = 0x93
    deref_size = 0x94
    xderef_size = 0x95
    nop = 0x96
    push_object_address = 0x97
    call2 = 0x98
    call4 = 0x99
    call_ref = 0x9a
    form_tls_address = 0x9b
    call_frame_cfa = 0x9c
    bit_piece = 0x9d
    implicit_value = 0x9e
    stack_value = 0x9f
    GNU_push_tls_address = 0xe0
    GNU_uninit = 0xf0
    GNU_encoded_addr = 0xf1
    GNU_implicit_pointer = 0xf2
    GNU_entry_value = 0xf3
    GNU_const_type = 0xf4
    GNU_regval_type = 0xf5
    GNU_deref_type = 0xf6
    GNU_convert = 0xf7
    GNU_reinterpret = 0xf9
    GNU_parameter_ref = 0xfa
    lo_user = 0xe0
    hi_user = 0xff

    @classmethod
    def str(cls, value):
        try:
            return f'DW_OP_{cls(value).name}'
        except ValueError:
            return hex(value)


class DW_TAG(enum.IntEnum):
    array_type = 0x1
    class_type = 0x2
    entry_point = 0x3
    enumeration_type = 0x4
    formal_parameter = 0x5
    imported_declaration = 0x8
    label = 0xa
    lexical_block = 0xb
    member = 0xd
    pointer_type = 0xf
    reference_type = 0x10
    compile_unit = 0x11
    string_type = 0x12
    structure_type = 0x13
    subroutine_type = 0x15
    typedef = 0x16
    union_type = 0x17
    unspecified_parameters = 0x18
    variant = 0x19
    common_block = 0x1a
    common_inclusion = 0x1b
    inheritance = 0x1c
    inlined_subroutine = 0x1d
    module = 0x1e
    ptr_to_member_type = 0x1f
    set_type = 0x20
    subrange_type = 0x21
    with_stmt = 0x22
    access_declaration = 0x23
    base_type = 0x24
    catch_block = 0x25
    const_type = 0x26
    constant = 0x27
    enumerator = 0x28
    file_type = 0x29
    friend = 0x2a
    namelist = 0x2b
    namelist_item = 0x2c
    packed_type = 0x2d
    subprogram = 0x2e
    template_type_parameter = 0x2f
    template_value_parameter = 0x30
    thrown_type = 0x31
    try_block = 0x32
    variant_part = 0x33
    variable = 0x34
    volatile_type = 0x35
    dwarf_procedure = 0x36
    restrict_type = 0x37
    interface_type = 0x38
    namespace = 0x39
    imported_module = 0x3a
    unspecified_type = 0x3b
    partial_unit = 0x3c
    imported_unit = 0x3d
    condition = 0x3f
    shared_type = 0x40
    type_unit = 0x41
    rvalue_reference_type = 0x42
    template_alias = 0x43
    atomic_type = 0x47
    lo_user = 0x4080
    MIPS_loop = 0x4081
    format_label = 0x4101
    function_template = 0x4102
    class_template = 0x4103
    GNU_BINCL = 0x4104
    GNU_EINCL = 0x4105
    GNU_template_template_param = 0x4106
    GNU_template_parameter_pack = 0x4107
    GNU_formal_parameter_pack = 0x4108
    GNU_call_site = 0x4109
    GNU_call_site_parameter = 0x410a
    hi_user = 0xffff

    @classmethod
    def str(cls, value):
        try:
            return f'DW_TAG_{cls(value).name}'
        except ValueError:
            return hex(value)


TYPE_TAGS = {
    DW_TAG.array_type,
    DW_TAG.atomic_type,
    DW_TAG.base_type,
    DW_TAG.class_type,
    DW_TAG.const_type,
    DW_TAG.enumeration_type,
    DW_TAG.file_type,
    DW_TAG.interface_type,
    DW_TAG.packed_type,
    DW_TAG.pointer_type,
    DW_TAG.ptr_to_member_type,
    DW_TAG.reference_type,
    DW_TAG.restrict_type,
    DW_TAG.rvalue_reference_type,
    DW_TAG.set_type,
    DW_TAG.shared_type,
    DW_TAG.string_type,
    DW_TAG.structure_type,
    DW_TAG.subrange_type,
    DW_TAG.subroutine_type,
    DW_TAG.template_type_parameter,
    DW_TAG.thrown_type,
    DW_TAG.typedef,
    DW_TAG.union_type,
    DW_TAG.unspecified_type,
    DW_TAG.volatile_type,
}

QUALIFIED_TYPE_TAGS = {
    DW_TAG.atomic_type,
    DW_TAG.const_type,
    DW_TAG.packed_type,
    DW_TAG.restrict_type,
    DW_TAG.shared_type,
    DW_TAG.volatile_type,
}


cdef class DwarfFormatError(Exception):
    pass


cdef class DwarfAttribNotFoundError(Exception):
    pass


cdef class DwarfFile:
    cdef dict sections

    def __init__(self, sections):
        self.sections = sections

    cdef int get_section_buffer(self, str name, Py_buffer *buffer) except -1:
        try:
            data = self.sections[name]
        except KeyError:
            raise DwarfFormatError(f'no {name} section')
        PyObject_GetBuffer(data, buffer, PyBUF_SIMPLE)
        return 0

    cdef CompilationUnit cu_header(self, Py_buffer *debug_info_buffer,
                                   Py_buffer *debug_abbrev_buffer,
                                   Py_ssize_t offset):
        cdef CompilationUnit cu
        cu = parse_compilation_unit_header(<const char *>debug_info_buffer.buf,
                                           debug_info_buffer.len, &offset,
                                           self)
        offset = cu.debug_abbrev_offset
        parse_abbrev_table(<const char *>debug_abbrev_buffer.buf,
                           debug_abbrev_buffer.len, &offset, &cu._abbrev_table)
        return cu

    def cu(self, Py_ssize_t offset):
        cdef Py_buffer debug_info_buffer
        cdef Py_buffer debug_abbrev_buffer

        self.get_section_buffer('.debug_info', &debug_info_buffer)
        try:
            self.get_section_buffer('.debug_abbrev', &debug_abbrev_buffer)
            try:
                    return self.cu_header(&debug_info_buffer,
                                          &debug_abbrev_buffer, offset)
            finally:
                PyBuffer_Release(&debug_abbrev_buffer)
        finally:
            PyBuffer_Release(&debug_info_buffer)

    def cu_headers(self):
        cdef CompilationUnit cu
        cdef Py_buffer debug_info_buffer
        cdef Py_buffer debug_abbrev_buffer
        cdef Py_ssize_t offset = 0

        self.get_section_buffer('.debug_info', &debug_info_buffer)
        try:
            self.get_section_buffer('.debug_abbrev', &debug_abbrev_buffer)
            try:
                while offset < debug_info_buffer.len:
                    cu = self.cu_header(&debug_info_buffer,
                                        &debug_abbrev_buffer, offset)
                    yield cu
                    offset = cu.end_offset()
            finally:
                PyBuffer_Release(&debug_abbrev_buffer)
        finally:
            PyBuffer_Release(&debug_info_buffer)


cdef struct AttribSpec:
    uint64_t name
    uint64_t form


cdef struct AbbrevDecl:
    uint64_t tag
    bint children
    uint64_t num_attribs
    AttribSpec *attribs


# Technically, abbreviation codes don't have to be sequential. In practice, GCC
# seems to always generate sequential codes, so we can get away with a flat
# array.
cdef struct AbbrevTable:
    uint64_t num_decls
    AbbrevDecl *decls


cdef class CompilationUnit:
    cdef public DwarfFile dwarf_file
    # Offset from the beginning of .debug_info (or whatever section it was
    # parsed from).
    cdef public Py_ssize_t offset

    cdef public uint64_t unit_length
    cdef public uint16_t version
    cdef public uint64_t debug_abbrev_offset
    cdef public uint8_t address_size
    cdef public bint is_64_bit

    cdef str _name

    cdef AbbrevTable _abbrev_table

    def __dealloc__(self):
        for i in range(self._abbrev_table.num_decls):
            PyMem_Free(self._abbrev_table.decls[i].attribs)
        PyMem_Free(self._abbrev_table.decls)

    cpdef str name(self):
        if self._name is not None:
            return self._name

        self._name = self.die().name()
        return self._name

    cpdef Py_ssize_t end_offset(self):
        return self.offset + (12 if self.is_64_bit else 4) + self.unit_length

    cpdef Py_ssize_t die_offset(self):
        return self.offset + (23 if self.is_64_bit else 11)

    cdef AbbrevDecl *abbrev_decl(self, uint64_t code) except NULL:
        if code < 1 or code > self._abbrev_table.num_decls:
            raise DwarfFormatError(f'unknown abbreviation code {code}')
        return &self._abbrev_table.decls[code - 1]

    cpdef Die die(self, Py_ssize_t offset=0):
        cdef Py_buffer buffer

        if offset == 0:
            offset = self.die_offset()
        else:
            offset += self.offset

        self.dwarf_file.get_section_buffer('.debug_info', &buffer)
        try:
            return parse_die(<const char *>buffer.buf, buffer.len, &offset,
                             self, False)
        finally:
            PyBuffer_Release(&buffer)


cdef struct DieAttribValuePtr:
    # Offset from the beginning of the section.
    Py_ssize_t offset
    Py_ssize_t length


cdef union DieAttribValue:
    # DW_FORM_addr, DW_FORM_udata, DW_FORM_flag{,_present},
    # DW_FORM_sec_offset, DW_FORM_ref{1,2,4,8,_sig8,_udata,_addr},
    # and DW_FORM_strp. For DW_FORM_flag_present, always 1.
    uint64_t u

    # DW_FORM_sdata.
    int64_t s

    # DW_FORM_data{1,2,4,8}
    char data[8]

    # DW_FORM_block{,1,2,4}, DW_FORM_exprloc, and DW_FORM_string.
    DieAttribValuePtr ptr


cdef struct DieAttrib:
    uint64_t name
    uint64_t form
    DieAttribValue value


cdef class Die:
    cdef public CompilationUnit cu
    # Offset from the beginning of the section.
    cdef public Py_ssize_t offset
    cdef public Py_ssize_t length
    cdef public uint64_t tag
    cdef list _children
    # XXX: Cython doesn't support variable-size objects.
    cdef DieAttrib *attribs
    cdef Py_ssize_t num_attribs

    def __dealloc__(self):
        PyMem_Free(self.attribs)

    def __len__(self):
        return self.num_attribs

    def __getitem__(self, i):
        if i < 0 or i >= self.num_attribs:
            raise IndexError('attribute index out of range')
        cdef const DieAttrib *attrib = &self.attribs[i]
        return (attrib.name, attrib.form, self.attrib_value(attrib))

    def __eq__(self, other):
        if not isinstance(other, Die):
            return False
        cdef Die other_die = other
        return (self.cu == other_die.cu and
                self.offset == other_die.offset and
                self.length == other_die.length and
                self.tag == other_die.tag and
                list(self) == list(other_die))

    def __contains__(self, item):
        for i in range(self.num_attribs):
            if self.attribs[i].name == item:
                return True
        return False

    cdef const DieAttrib *find_attrib(self, uint64_t name) except NULL:
        for i in range(self.num_attribs):
            if self.attribs[i].name == name:
                return &self.attribs[i]
        else:
            raise DwarfAttribNotFoundError(f'no attribute with name {DW_AT.str(name)}')

    @staticmethod
    cdef uint64_t attrib_sec_offset(const DieAttrib *attrib):
        if attrib.form == DW_FORM.data4:
            # DWARF 2 and 3
            return (<const uint32_t *>&attrib.value.data[0])[0]
        elif attrib.form == DW_FORM.sec_offset:
            return attrib.value.u
        else:
            raise DwarfFormatError(f'unknown form {DW_FORM.str(attrib.form)} for section offset')

    cdef object attrib_value(self, const DieAttrib *attrib):
        cdef Py_buffer buffer
        cdef Py_ssize_t offset

        if (attrib.form == DW_FORM.addr or
                attrib.form == DW_FORM.udata or
                attrib.form == DW_FORM.ref_udata or
                attrib.form == DW_FORM.ref1 or
                attrib.form == DW_FORM.ref2 or
                attrib.form == DW_FORM.ref4 or
                attrib.form == DW_FORM.ref8 or
                attrib.form == DW_FORM.ref_sig8 or
                attrib.form == DW_FORM.sec_offset or
                attrib.form == DW_FORM.strp):
            return attrib.value.u
        elif (attrib.form == DW_FORM.block1 or
              attrib.form == DW_FORM.block2 or
              attrib.form == DW_FORM.block4 or
              attrib.form == DW_FORM.block or
              attrib.form == DW_FORM.exprloc or
              attrib.form == DW_FORM.string):
            offset = attrib.value.ptr.offset
            self.cu.dwarf_file.get_section_buffer('.debug_info', &buffer)
            try:
                return read_bytes(<const char *>buffer.buf, buffer.len,
                                  &offset, attrib.value.ptr.length)
            finally:
                PyBuffer_Release(&buffer)
        elif attrib.form == DW_FORM.data1:
            return PyBytes_FromStringAndSize(attrib.value.data, 1)
        elif attrib.form == DW_FORM.data2:
            return PyBytes_FromStringAndSize(attrib.value.data, 2)
        elif attrib.form == DW_FORM.data4:
            return PyBytes_FromStringAndSize(attrib.value.data, 4)
        elif attrib.form == DW_FORM.data8:
            return PyBytes_FromStringAndSize(attrib.value.data, 8)
        elif attrib.form == DW_FORM.sdata:
            return attrib.value.s
        elif attrib.form == DW_FORM.flag:
            return bool(attrib.value.u)
        elif attrib.form == DW_FORM.flag_present:
            return True
        else:
            raise DwarfFormatError(f'unknown form {DW_FORM.str(attrib.form)}')

    def find(self, at):
        cdef const DieAttrib *attrib = self.find_attrib(at)
        return attrib.form, self.attrib_value(attrib)

    def find_constant(self, at):
        cdef const DieAttrib *attrib = self.find_attrib(at)
        if attrib.form == DW_FORM.data1:
            return (<const uint8_t *>&attrib.value.data[0])[0]
        elif attrib.form == DW_FORM.data2:
            return (<const uint16_t *>&attrib.value.data[0])[0]
        elif attrib.form == DW_FORM.data4:
            return (<const uint32_t *>&attrib.value.data[0])[0]
        elif attrib.form == DW_FORM.data8:
            return (<const uint64_t *>&attrib.value.data[0])[0]
        elif attrib.form == DW_FORM.udata:
            return attrib.value.u
        elif attrib.form == DW_FORM.sdata:
            return attrib.value.s
        else:
            raise DwarfFormatError(f'unknown form {DW_FORM.str(attrib.form)} for constant')

    cpdef find_string(self, uint64_t at):
        cdef const DieAttrib *attrib = self.find_attrib(at)
        cdef Py_buffer buffer
        cdef Py_ssize_t offset

        if attrib.form == DW_FORM.strp:
            offset = attrib.value.u
            self.cu.dwarf_file.get_section_buffer('.debug_str', &buffer)
            try:
                return read_str(<const char *>buffer.buf, buffer.len, &offset)
            finally:
                PyBuffer_Release(&buffer)
        elif attrib.form == DW_FORM.string:
            self.cu.dwarf_file.get_section_buffer('.debug_info', &buffer)
            try:
                return PyUnicode_FromStringAndSize(<const char *>buffer.buf + attrib.value.ptr.offset,
                                                   attrib.value.ptr.length)
            finally:
                PyBuffer_Release(&buffer)
        else:
            raise DwarfFormatError(f'unknown form {DW_FORM.str(attrib.form)} for string')

    cpdef find_sec_offset(self, uint64_t at):
        cdef const DieAttrib *attrib = self.find_attrib(at)
        return Die.attrib_sec_offset(attrib)

    def find_flag(self, at):
        cdef const DieAttrib *attrib
        try:
            attrib = self.find_attrib(at)
        except DwarfAttribNotFoundError:
            return False
        if attrib.form == DW_FORM.flag_present:
            return True
        elif attrib.form == DW_FORM.flag:
            return bool(attrib.value.u)
        else:
            raise DwarfFormatError(f'unknown form {DW_FORM.str(attrib.form)} for flag')

    cpdef str name(self):
        return self.find_string(DW_AT.name)

    def size(self):
        return self.find_constant(DW_AT.byte_size)

    def type(self):
        cdef const DieAttrib *attrib = self.find_attrib(DW_AT.type)

        if (attrib.form == DW_FORM.ref1 or attrib.form == DW_FORM.ref2 or
                attrib.form == DW_FORM.ref4 or attrib.form == DW_FORM.ref8 or
                attrib.form == DW_FORM.ref_udata):
            return self.cu.die(attrib.value.u)
        elif attrib.form == DW_FORM.ref_addr:
            raise NotImplementedError('DW_FORM_ref_addr is not implemented')
        elif attrib.form == DW_FORM.ref_sig8:
            raise NotImplementedError('DW_FORM_ref_sig8 is not implemented')
        else:
            raise DwarfFormatError(f'unknown form {DW_FORM.str(attrib.form)} for DW_AT_type')

    cpdef list children(self):
        # Note that _children isn't a cache; it's used for DIEs with no
        # children or DIEs which we had to parse the children for anyways when
        # we were parsing a list of siblings.
        if self._children is not None:
            return self._children

        cdef Py_buffer buffer
        cdef Py_ssize_t offset

        offset = self.offset + self.length

        self.cu.dwarf_file.get_section_buffer('.debug_info', &buffer)
        try:
            return parse_die_siblings(<const char *>buffer.buf, buffer.len,
                                      &offset, self.cu)
        finally:
            PyBuffer_Release(&buffer)

    def is_type(self):
        return self.tag in TYPE_TAGS

    def is_qualified_type(self):
        return self.tag in QUALIFIED_TYPE_TAGS

    def unqualified(self):
        if not self.is_type():
            raise ValueError('not a type DIE')
        die = self
        while die.is_qualified_type() or die.tag == DW_TAG.typedef:
            die = die.type()
        return die


def parse_uleb128_and_offset(s, Py_ssize_t offset):
    cdef uint64_t ret
    cdef Py_buffer buffer
    PyObject_GetBuffer(s, &buffer, PyBUF_SIMPLE)
    try:
        read_uleb128(<const char *>buffer.buf, buffer.len, &offset, &ret)
        return ret, offset
    finally:
        PyBuffer_Release(&buffer)


def parse_sleb128_and_offset(s, Py_ssize_t offset):
    cdef int64_t ret
    cdef Py_buffer buffer
    PyObject_GetBuffer(s, &buffer, PyBUF_SIMPLE)
    try:
        read_sleb128(<const char *>buffer.buf, buffer.len, &offset, &ret)
        return ret, offset
    finally:
        PyBuffer_Release(&buffer)


def parse_uleb128(s, Py_ssize_t offset=0):
    return parse_uleb128_and_offset(s, offset)[0]


def parse_sleb128(s, Py_ssize_t offset=0):
    return parse_sleb128_and_offset(s, offset)[0]


cdef int realloc_abbrev_decls(AbbrevDecl **abbrev_decls, Py_ssize_t n) except -1:
    if n > PY_SSIZE_T_MAX // <Py_ssize_t>sizeof(AbbrevDecl):
        raise MemoryError()

    cdef AbbrevDecl *tmp = <AbbrevDecl *>PyMem_Realloc(abbrev_decls[0],
                                                       n * sizeof(AbbrevDecl))
    if tmp == NULL:
        raise MemoryError()

    abbrev_decls[0] = tmp
    return 0


cdef int realloc_attrib_specs(AttribSpec **attrib_specs, Py_ssize_t n) except -1:
    if n > PY_SSIZE_T_MAX // <Py_ssize_t>sizeof(AttribSpec):
        raise MemoryError()

    cdef AttribSpec *tmp = <AttribSpec *>PyMem_Realloc(attrib_specs[0],
                                                       n * sizeof(AttribSpec))
    if tmp == NULL:
        raise MemoryError()

    attrib_specs[0] = tmp
    return 0


cdef int parse_abbrev_decl(const char *buffer, Py_ssize_t buffer_size,
                           Py_ssize_t *offset, AbbrevTable *abbrev_table,
                           uint64_t *decls_capacity) except -1:
    cdef uint64_t code

    try:
        read_uleb128(buffer, buffer_size, offset, &code)
    except EOFError:
        raise DwarfFormatError('abbreviation declaration code is truncated')
    if code == 0:
        return 0
    if code != abbrev_table.num_decls + 1:
        raise NotImplementedError('abbreviation table is not sequential')

    if abbrev_table.num_decls >= decls_capacity[0]:
        decls_capacity[0] *= 2
        realloc_abbrev_decls(&abbrev_table.decls, decls_capacity[0])

    cdef AbbrevDecl *decl = &abbrev_table.decls[abbrev_table.num_decls]
    decl.attribs = NULL
    decl.num_attribs = 0
    abbrev_table.num_decls += 1

    try:
        read_uleb128(buffer, buffer_size, offset, &decl.tag)
    except EOFError:
        raise DwarfFormatError('abbreviation declaration tag is truncated')
    cdef uint8_t children
    try:
        read_u8(buffer, buffer_size, offset, &children)
    except EOFError:
        raise DwarfFormatError('abbreviation declaration children flag is truncated')
    decl.children = children != DW_CHILDREN.no

    cdef uint64_t attribs_capacity = 1  # XXX: is this a good first guess?
    realloc_attrib_specs(&decl.attribs, attribs_capacity)

    cdef uint64_t name, form
    while True:
        try:
            read_uleb128(buffer, buffer_size, offset, &name)
        except EOFError:
            raise DwarfFormatError('abbreviation specification name is truncated')
        try:
            read_uleb128(buffer, buffer_size, offset, &form)
        except EOFError:
            raise DwarfFormatError('abbreviation specification form is truncated')
        if name == 0 and form == 0:
            break

        if decl.num_attribs >= attribs_capacity:
            attribs_capacity *= 2
            realloc_attrib_specs(&decl.attribs, attribs_capacity)

        decl.attribs[decl.num_attribs].name = name
        decl.attribs[decl.num_attribs].form = form
        decl.num_attribs += 1

    realloc_attrib_specs(&decl.attribs, decl.num_attribs)
    return 1


cdef int parse_abbrev_table(const char *buffer, Py_ssize_t buffer_size,
                            Py_ssize_t *offset,
                            AbbrevTable *abbrev_table) except -1:
    cdef uint64_t decls_capacity = 1  # XXX: is this a good first guess?

    abbrev_table.decls = NULL
    abbrev_table.num_decls = 0
    realloc_abbrev_decls(&abbrev_table.decls, decls_capacity)

    while parse_abbrev_decl(buffer, buffer_size, offset, abbrev_table,
                            &decls_capacity):
        pass
    realloc_abbrev_decls(&abbrev_table.decls, abbrev_table.num_decls)
    return 0


cdef CompilationUnit parse_compilation_unit_header(const char *buffer,
                                                   Py_ssize_t buffer_size,
                                                   Py_ssize_t *offset,
                                                   DwarfFile dwarf_file):
    cdef CompilationUnit cu = CompilationUnit.__new__(CompilationUnit)
    cu.dwarf_file = dwarf_file
    cu.offset = offset[0]

    cdef uint32_t tmp
    read_u32(buffer, buffer_size, offset, &tmp)
    cu.is_64_bit = tmp == 0xffffffffUL
    if cu.is_64_bit:
        read_u64(buffer, buffer_size, offset, &cu.unit_length)
    else:
        cu.unit_length = tmp

    read_u16(buffer, buffer_size, offset, &cu.version)
    if cu.version != 2 and cu.version != 3 and cu.version != 4:
        raise DwarfFormatError(f'unknown CU version {cu.version}')

    if cu.is_64_bit:
        read_u64(buffer, buffer_size, offset,
                 &cu.debug_abbrev_offset)
    else:
        read_u32_into_u64(buffer, buffer_size, offset, &cu.debug_abbrev_offset)

    read_u8(buffer, buffer_size, offset, &cu.address_size)

    return cu


cdef inline int parse_die_attrib(const char *buffer, Py_ssize_t buffer_size,
                                 Py_ssize_t *offset, DieAttrib *attrib,
                                 uint8_t address_size,
                                 bint is_64_bit) except -1:
    cdef uint64_t tmp

    # address
    if attrib.form == DW_FORM.addr:
        if address_size == 4:
            read_u32_into_u64(buffer, buffer_size, offset, &attrib.value.u)
        elif address_size == 8:
            read_u64(buffer, buffer_size, offset, &attrib.value.u)
        else:
            raise DwarfFormatError(f'unsupported address size {address_size}')
    elif (attrib.form == DW_FORM.block1 or  # block
          attrib.form == DW_FORM.block2 or
          attrib.form == DW_FORM.block4 or
          attrib.form == DW_FORM.exprloc):  # exprloc
        if attrib.form == DW_FORM.block1:
            read_u8_into_ssize_t(buffer, buffer_size, offset,
                                 &attrib.value.ptr.length)
        elif attrib.form == DW_FORM.block2:
            read_u16_into_ssize_t(buffer, buffer_size, offset,
                                  &attrib.value.ptr.length)
        elif attrib.form == DW_FORM.block4:
            read_u32_into_ssize_t(buffer, buffer_size, offset,
                                  &attrib.value.ptr.length)
        elif attrib.form == DW_FORM.exprloc:
            read_uleb128(buffer, buffer_size, offset, &tmp)
            if tmp > <uint64_t>PY_SSIZE_T_MAX:
                raise DwarfFormatError('attribute length too big')
            attrib.value.ptr.length = tmp
        check_bounds(buffer_size, offset[0], attrib.value.ptr.length)
        attrib.value.ptr.offset = offset[0]
        offset[0] += attrib.value.ptr.length
    # constant
    elif attrib.form == DW_FORM.data1:
        read_buffer(buffer, buffer_size, offset, &attrib.value.data, 1)
    elif attrib.form == DW_FORM.data2:
        read_buffer(buffer, buffer_size, offset, &attrib.value.data, 2)
    elif attrib.form == DW_FORM.data4:
        read_buffer(buffer, buffer_size, offset, &attrib.value.data, 4)
    elif attrib.form == DW_FORM.data8:
        read_buffer(buffer, buffer_size, offset, &attrib.value.data, 8)
    elif attrib.form == DW_FORM.sdata:
        read_sleb128(buffer, buffer_size, offset, &attrib.value.s)
    elif (attrib.form == DW_FORM.udata or     # constant
          attrib.form == DW_FORM.ref_udata):  # reference
        read_uleb128(buffer, buffer_size, offset, &attrib.value.u)
    elif (attrib.form == DW_FORM.ref_addr or    # reference
          attrib.form == DW_FORM.sec_offset or  # lineptr, loclistptr, macptr, rangelistptr
          attrib.form == DW_FORM.strp):         # string
        if is_64_bit:
            read_u64(buffer, buffer_size, offset, &attrib.value.u)
        else:
            read_u32_into_u64(buffer, buffer_size, offset, &attrib.value.u)
    # string
    elif attrib.form == DW_FORM.string:
        attrib.value.ptr.offset = offset[0]
        attrib.value.ptr.length = read_strlen(buffer, buffer_size, offset)
    # flag
    elif attrib.form == DW_FORM.flag_present:
        attrib.value.u = 1
    elif (attrib.form == DW_FORM.flag or  # flag
          attrib.form == DW_FORM.ref1):   # reference
        read_u8_into_u64(buffer, buffer_size, offset, &attrib.value.u)
    # reference
    elif attrib.form == DW_FORM.ref2:
        read_u16_into_u64(buffer, buffer_size, offset, &attrib.value.u)
    elif attrib.form == DW_FORM.ref4:
        read_u32_into_u64(buffer, buffer_size, offset, &attrib.value.u)
    elif (attrib.form == DW_FORM.ref8 or attrib.form == DW_FORM.ref_sig8):
        read_u64(buffer, buffer_size, offset, &attrib.value.u)
    elif DW_FORM.indirect:
        raise DwarfFormatError('DW_FORM_indirect is not supported')
    else:
        raise DwarfFormatError(f'unknown form 0x{attrib.form:x}')
    return 0


cdef list no_children = []


cdef list parse_die_siblings(const char *buffer, Py_ssize_t buffer_size,
                             Py_ssize_t *offset, CompilationUnit cu):
    cdef list children = []
    cdef Die child

    while True:
        child = parse_die(buffer, buffer_size, offset, cu, True)
        if child is None:
            break
        children.append(child)

    return children


cdef Die parse_die(const char *buffer, Py_ssize_t buffer_size,
                   Py_ssize_t *offset, CompilationUnit cu,
                   bint jump_to_sibling):
    cdef Die die = Die.__new__(Die)
    die.cu = cu
    die.offset = offset[0]

    cdef uint64_t code
    read_uleb128(buffer, buffer_size, offset, &code)
    if code == 0:
        return None

    cdef AbbrevDecl *decl = cu.abbrev_decl(code)

    die.tag = decl.tag
    die.attribs = <DieAttrib *>PyMem_Calloc(decl.num_attribs, sizeof(DieAttrib))
    if die.attribs == NULL:
        raise MemoryError()
    die.num_attribs = decl.num_attribs

    cdef uint64_t sibling_form = 0
    cdef Py_ssize_t sibling = 0
    for i in range(die.num_attribs):
        die.attribs[i].name = decl.attribs[i].name
        die.attribs[i].form = decl.attribs[i].form
        parse_die_attrib(buffer, buffer_size, offset, &die.attribs[i],
                         cu.address_size, cu.is_64_bit)
        if die.attribs[i].name == DW_AT.sibling:
            sibling_form = die.attribs[i].form
            sibling = die.attribs[i].value.u

    die.length = offset[0] - die.offset

    if not decl.children:
        die._children = no_children
    elif jump_to_sibling and sibling == 0:
        die._children = parse_die_siblings(buffer, buffer_size, offset, cu)
    elif jump_to_sibling:
        if sibling_form == DW_FORM.ref_addr:
            offset[0] = sibling
        else:
            offset[0] = cu.offset + sibling

    return die
